{
    "course":"Express js",
    
  "sections": [
    {
      "section": 1,
      "title": "Introduction to Express.js",
      "description": "Learn the fundamentals of Express.js, a minimal and flexible Node.js framework for building web applications and APIs quickly.",
      "lessons": [
        {
          "id": 1,
          "title": "What is Express.js and Why Use It",
          "content": "Express.js is a minimal, fast, and flexible Node.js framework that simplifies web application and API development. It provides robust routing, middleware support, and integration with databases and template engines.",
          "examples": [
            {
              "code": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send('Hello Express.js!');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on http://localhost:3000');\n});",
              "description": "A basic Express server responding with 'Hello Express.js!' on the root route."
            }
          ],
          "quiz": [
            {
              "question": "Which of the following best describes Express.js?",
              "options": ["Minimal Node.js framework", "Database engine", "CSS framework", "React library"],
              "answer": "Minimal Node.js framework",
              "hint": "It is used for building servers and APIs.",
              "explanation": "Express.js is a lightweight framework for Node.js that simplifies server and API creation."
            },
            {
              "question": "What language is Express.js built on?",
              "options": ["JavaScript", "Python", "Ruby", "Java"],
              "answer": "JavaScript",
              "hint": "Node.js framework language.",
              "explanation": "Express.js runs on Node.js and uses JavaScript for server-side coding."
            }
          ],
          "challenge": "Create an Express server that responds with 'Welcome to Express!' on the root route.",
          "tips": [
            "Always call app.listen() to start the server.",
            "Keep routes simple when starting out."
          ]
        },
        {
          "id": 2,
          "title": "Setting Up Express Project",
          "content": "Initialize a new Node.js project, install Express, and set up a basic folder structure for your application.",
          "examples": [
            {
              "code": "mkdir my-express-app\ncd my-express-app\nnpm init -y\nnpm install express\n\n// Folder structure\nmy-express-app/\n├── index.js\n├── package.json\n└── node_modules/",
              "description": "Initialize an Express project with npm and install dependencies."
            }
          ],
          "quiz": [
            {
              "question": "Which command installs Express in a Node.js project?",
              "options": ["npm install express", "npm install node", "npm init express", "npm add express"],
              "answer": "npm install express",
              "hint": "Think about npm package installation.",
              "explanation": "Use 'npm install express' to add Express to your project dependencies."
            },
            {
              "question": "What command initializes a new Node.js project with default settings?",
              "options": ["npm init -y", "npm start", "npm install", "npm init project"],
              "answer": "npm init -y",
              "hint": "It generates a package.json file automatically.",
              "explanation": "The '-y' flag creates a package.json file with default options."
            }
          ],
          "challenge": "Set up a new Express project and start a server that listens on port 3000.",
          "tips": [
            "Use meaningful folder and file names for scalability.",
            "Keep dependencies organized in package.json."
          ]
        }
      ]
    },
    {
      "section": 2,
      "title": "Routing in Express",
      "description": "Learn how to define routes, handle dynamic parameters, and organize routes modularly in Express.",
      "lessons": [
        {
          "id": 3,
          "title": "Basic Routing",
          "content": "Use app.get(), app.post(), and app.all() to define routes and handle HTTP methods in Express.",
          "examples": [
            {
              "code": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => res.send('GET request'));\napp.post('/', (req, res) => res.send('POST request'));\napp.all('/all', (req, res) => res.send('All methods'));\n\napp.listen(3000);",
              "description": "Demonstrates basic routing for GET, POST, and all HTTP methods."
            }
          ],
          "quiz": [
            {
              "question": "Which method handles all HTTP methods?",
              "options": ["app.all()", "app.get()", "app.post()", "app.use()"],
              "answer": "app.all()",
              "hint": "It’s used for universal route handling.",
              "explanation": "app.all() matches all HTTP methods for a given path."
            },
            {
              "question": "Which method is used to handle GET requests?",
              "options": ["app.get()", "app.post()", "app.put()", "app.delete()"],
              "answer": "app.get()",
              "hint": "Used for reading data.",
              "explanation": "app.get() defines a route that handles HTTP GET requests."
            }
          ],
          "challenge": "Create GET and POST routes for '/' and test them with Postman or browser.",
          "tips": [
            "Keep route handlers simple.",
            "Use res.send() for sending responses quickly during testing."
          ]
        },
        {
          "id": 4,
          "title": "Route Parameters & Query Strings",
          "content": "Learn to handle dynamic URLs using route parameters and query strings via req.params and req.query.",
          "examples": [
            {
              "code": "app.get('/user/:id', (req, res) => {\n  res.send(`User ID: ${req.params.id}`);\n});\n\napp.get('/search', (req, res) => {\n  res.send(`Query: ${req.query.q}`);\n});",
              "description": "Demonstrates dynamic route parameters and query string handling."
            }
          ],
          "quiz": [
            {
              "question": "How do you access route parameters?",
              "options": ["req.params", "req.query", "req.body", "req.url"],
              "answer": "req.params",
              "hint": "Parameters defined in the URL path.",
              "explanation": "Route parameters are accessed via req.params in Express."
            },
            {
              "question": "How do you access query string parameters?",
              "options": ["req.query", "req.params", "req.body", "req.header"],
              "answer": "req.query",
              "hint": "Used for URL parameters after '?'",
              "explanation": "Query string values in URLs are accessible via req.query."
            }
          ],
          "challenge": "Create a route /product/:id and /search?q=term, returning the respective parameter values.",
          "tips": [
            "Validate parameters to avoid errors.",
            "Use descriptive names for route parameters."
          ]
        },
        {
          "id": 5,
          "title": "Router & Modular Routes",
          "content": "Use express.Router() to organize routes in separate modules for better code maintainability.",
          "examples": [
            {
              "code": "const express = require('express');\nconst app = express();\nconst userRouter = express.Router();\n\nuserRouter.get('/:id', (req, res) => {\n  res.send(`User ID: ${req.params.id}`);\n});\n\napp.use('/users', userRouter);\n\napp.listen(3000);",
              "description": "Separates user-related routes using a router module."
            }
          ],
          "quiz": [
            {
              "question": "Which Express object helps create modular routes?",
              "options": ["express.Router()", "express.Module()", "express.Route()", "express.Handle()"],
              "answer": "express.Router()",
              "hint": "Use for separating route logic.",
              "explanation": "express.Router() creates a new router object to handle related routes modularly."
            },
            {
              "question": "How do you mount a router on a path?",
              "options": ["app.use('/path', router)", "app.get('/path', router)", "app.router('/path', router)", "router.mount('/path')"],
              "answer": "app.use('/path', router)",
              "hint": "Think about middleware mounting.",
              "explanation": "Routers are mounted using app.use() with the base path."
            }
          ],
          "challenge": "Create a separate router for '/products' with routes for listing and viewing products.",
          "tips": [
            "Keep routers small and focused.",
            "Group related routes together logically."
          ]
        }
      ]
    },
    {
      "section": 3,
      "title": "Middleware",
      "description": "Learn how middleware works in Express.js, including built-in middleware, custom middleware, and how to manage request and response processing.",
      "lessons": [
        {
          "id": 6,
          "title": "Understanding Middleware",
          "content": "Middleware are functions that have access to the request, response, and next() function. They can execute code, modify req/res objects, end requests, or call the next middleware.",
          "examples": [
            {
              "code": "const express = require('express');\nconst app = express();\n\n// Simple middleware\napp.use((req, res, next) => {\n  console.log('Request URL:', req.url);\n  next();\n});\n\napp.get('/', (req, res) => res.send('Hello Middleware'));\napp.listen(3000);",
              "description": "A middleware logs each request URL before passing control to the next handler."
            }
          ],
          "quiz": [
            {
              "question": "What does middleware in Express.js have access to?",
              "options": ["req, res, next", "req only", "res only", "database"],
              "answer": "req, res, next",
              "hint": "Think of the three core objects in Express request handling.",
              "explanation": "Middleware functions receive the request, response objects, and a next function to pass control."
            },
            {
              "question": "What is next() used for in middleware?",
              "options": ["Pass control to the next middleware", "Terminate server", "Send response automatically", "Log requests"],
              "answer": "Pass control to the next middleware",
              "hint": "Without it, the request may hang.",
              "explanation": "Calling next() ensures the request proceeds to the next middleware or route handler."
            }
          ],
          "challenge": "Write a middleware that logs request method and path for all incoming requests.",
          "tips": [
            "Always call next() unless you end the response.",
            "Keep middleware focused on a single responsibility."
          ]
        },
        {
          "id": 7,
          "title": "Built-in Middleware",
          "content": "Express provides built-in middleware like express.json() for parsing JSON, express.urlencoded() for URL-encoded data, and express.static() for serving static files.",
          "examples": [
            {
              "code": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(express.static('public'));\n\napp.post('/data', (req, res) => res.json(req.body));\napp.listen(3000);",
              "description": "Built-in middleware parses JSON bodies, URL-encoded data, and serves static files from 'public' folder."
            }
          ],
          "quiz": [
            {
              "question": "Which middleware parses JSON request bodies?",
              "options": ["express.json()", "express.urlencoded()", "express.static()", "body-parser"],
              "answer": "express.json()",
              "hint": "Used for API POST requests.",
              "explanation": "express.json() automatically parses incoming JSON requests."
            },
            {
              "question": "Which middleware serves static files?",
              "options": ["express.static()", "express.json()", "express.urlencoded()", "express.middleware()"],
              "answer": "express.static()",
              "hint": "Use it for CSS, images, or JS files.",
              "explanation": "express.static() maps a folder to serve static content directly."
            }
          ],
          "challenge": "Serve images and CSS files from a 'public' folder using express.static().",
          "tips": [
            "Use express.json() for APIs and express.urlencoded() for form submissions.",
            "Keep static assets in a dedicated folder."
          ]
        },
        {
          "id": 8,
          "title": "Custom Middleware",
          "content": "Create your own middleware for logging, authentication, error handling, or modifying request/response objects.",
          "examples": [
            {
              "code": "function logger(req, res, next) {\n  console.log(`${req.method} ${req.url}`);\n  next();\n}\n\napp.use(logger);\n\napp.get('/', (req, res) => res.send('Hello Custom Middleware'));",
              "description": "A custom middleware logs method and URL for every request."
            }
          ],
          "quiz": [
            {
              "question": "What can custom middleware do?",
              "options": ["Log requests, authenticate, modify req/res", "Only log requests", "Only send responses", "Restart server"],
              "answer": "Log requests, authenticate, modify req/res",
              "hint": "Middleware can handle multiple tasks.",
              "explanation": "Custom middleware is flexible and can perform logging, authentication, error handling, or modify req/res objects."
            }
          ],
          "challenge": "Create a middleware that checks for a custom header 'x-api-key' and rejects requests without it.",
          "tips": [
            "Keep middleware reusable and modular.",
            "Place global middleware before routes for consistent application."
          ]
        }
      ]
    },
    {
      "section": 4,
      "title": "Handling Requests & Responses",
      "description": "Understand how to work with request and response objects in Express.js to handle client data and send proper responses.",
      "lessons": [
        {
          "id": 9,
          "title": "Request Object",
          "content": "The request object contains information about the HTTP request including headers, body, query parameters, and URL params.",
          "examples": [
            {
              "code": "app.post('/submit', (req, res) => {\n  console.log(req.body); // JSON data from client\n  console.log(req.query); // URL query string\n  console.log(req.params); // Route parameters\n  res.send('Received data');\n});",
              "description": "Access various parts of the request object for handling data."
            }
          ],
          "quiz": [
            {
              "question": "How do you access route parameters in Express?",
              "options": ["req.params", "req.query", "req.body", "req.headers"],
              "answer": "req.params",
              "hint": "Defined in the URL path.",
              "explanation": "Route parameters are available via req.params."
            },
            {
              "question": "Where can query string values be accessed?",
              "options": ["req.query", "req.params", "req.body", "req.url"],
              "answer": "req.query",
              "hint": "After '?' in the URL.",
              "explanation": "Query string parameters are in req.query."
            }
          ],
          "challenge": "Create a POST route '/register/:id' and log body, params, and query values.",
          "tips": [
            "Use body-parser or express.json() for JSON POST requests.",
            "Validate request data before processing."
          ]
        },
        {
          "id": 10,
          "title": "Response Object",
          "content": "The response object is used to send back HTML, JSON, redirects, or status codes to the client.",
          "examples": [
            {
              "code": "app.get('/json', (req, res) => res.json({ message: 'Hello JSON' }));\napp.get('/redirect', (req, res) => res.redirect('/'));\napp.get('/status', (req, res) => res.status(404).send('Not Found'));",
              "description": "Sending JSON, redirecting, and setting HTTP status codes."
            }
          ],
          "quiz": [
            {
              "question": "Which method sends a JSON response?",
              "options": ["res.json()", "res.send()", "res.redirect()", "res.status()"],
              "answer": "res.json()",
              "hint": "Used for APIs.",
              "explanation": "res.json() automatically sets Content-Type to application/json and sends the object."
            },
            {
              "question": "How do you redirect a client to another URL?",
              "options": ["res.redirect()", "res.send()", "res.json()", "res.status()"],
              "answer": "res.redirect()",
              "hint": "Think of HTTP 3xx response.",
              "explanation": "res.redirect() sends an HTTP redirect to the client."
            }
          ],
          "challenge": "Create routes to return JSON data, redirect to '/', and send a 403 status code.",
          "tips": [
            "Always send a response to prevent hanging requests.",
            "Set proper status codes for API clarity."
          ]
        }
      ]
    },
        {
      "section": 5,
      "title": "Templating & Views",
      "description": "Learn to render dynamic HTML content in Express using template engines like EJS, Pug, or Handlebars.",
      "lessons": [
        {
          "id": 11,
          "title": "Using Template Engines",
          "content": "Template engines allow embedding dynamic data into HTML. Express supports engines like EJS, Pug, and Handlebars.",
          "examples": [
            {
              "code": "const express = require('express');\nconst app = express();\napp.set('view engine', 'ejs');\n\napp.get('/', (req, res) => {\n  res.render('index', { title: 'Home Page', message: 'Hello Express!' });\n});",
              "description": "Using EJS template engine to render dynamic HTML content."
            }
          ],
          "quiz": [
            {
              "question": "Which method sets the template engine in Express?",
              "options": ["app.set('view engine', 'ejs')", "app.engine('ejs')", "res.render()", "app.use()"],
              "answer": "app.set('view engine', 'ejs')",
              "hint": "This configures Express globally.",
              "explanation": "app.set('view engine', 'ejs') tells Express to use EJS for rendering templates."
            },
            {
              "question": "How do you render a template in Express?",
              "options": ["res.render('templateName', { data })", "res.sendFile()", "res.json()", "app.get()"],
              "answer": "res.render('templateName', { data })",
              "hint": "You provide the template name and optional data.",
              "explanation": "res.render() renders the template file with the provided dynamic data."
            }
          ],
          "challenge": "Create an EJS template that displays a list of products passed from the server.",
          "tips": [
            "Keep your templates in a 'views' folder.",
            "Pass only necessary data to templates for security and clarity."
          ]
        },
        {
          "id": 12,
          "title": "Rendering Dynamic Content",
          "content": "Pass variables and objects from your Express backend to templates to dynamically generate HTML content based on server data.",
          "examples": [
            {
              "code": "app.get('/users', (req, res) => {\n  const users = [{name: 'Alice'}, {name: 'Bob'}];\n  res.render('users', { users });\n});",
              "description": "Passes an array of users to the template for dynamic rendering."
            }
          ],
          "quiz": [
            {
              "question": "How do you access passed variables in an EJS template?",
              "options": ["<%= variableName %>", "{{ variableName }}", "{% variableName %}", "res.variableName"],
              "answer": "<%= variableName %>",
              "hint": "EJS syntax for embedding JS variables.",
              "explanation": "Use <%= variableName %> inside EJS templates to output values dynamically."
            }
          ],
          "challenge": "Create a template that displays user names in an unordered list.",
          "tips": [
            "Escape variables to prevent XSS attacks.",
            "Use loops in templates to render arrays efficiently."
          ]
        }
      ]
    },
    {
      "section": 6,
      "title": "Working with APIs",
      "description": "Learn how to build RESTful APIs using Express and integrate them with databases like MongoDB for dynamic data handling.",
      "lessons": [
        {
          "id": 13,
          "title": "Creating RESTful APIs",
          "content": "Define routes in Express that handle CRUD operations (GET, POST, PUT, DELETE) for building APIs that clients can consume.",
          "examples": [
            {
              "code": "app.get('/api/users', (req, res) => res.json([{ name: 'Alice' }, { name: 'Bob' }]));\napp.post('/api/users', (req, res) => res.status(201).json(req.body));",
              "description": "Simple GET and POST routes for user API endpoints."
            }
          ],
          "quiz": [
            {
              "question": "Which HTTP method is used to update data in a REST API?",
              "options": ["PUT", "GET", "POST", "DELETE"],
              "answer": "PUT",
              "hint": "Think about modifying existing resources.",
              "explanation": "PUT is commonly used to update existing resources in RESTful APIs."
            },
            {
              "question": "Which status code indicates successful resource creation?",
              "options": ["201", "200", "404", "500"],
              "answer": "201",
              "hint": "Created successfully.",
              "explanation": "201 status code indicates that a resource was successfully created."
            }
          ],
          "challenge": "Create an API with GET, POST, PUT, DELETE routes for managing tasks.",
          "tips": [
            "Use express.json() to parse JSON request bodies.",
            "Always set proper HTTP status codes for clarity."
          ]
        },
        {
          "id": 14,
          "title": "Connecting with Database",
          "content": "Integrate MongoDB with Express using Mongoose to store, retrieve, and manipulate data in your APIs.",
          "examples": [
            {
              "code": "const mongoose = require('mongoose');\nmongoose.connect('mongodb://localhost:27017/mydb');\n\nconst userSchema = new mongoose.Schema({ name: String });\nconst User = mongoose.model('User', userSchema);\n\napp.post('/users', async (req, res) => {\n  const user = new User(req.body);\n  await user.save();\n  res.status(201).json(user);\n});",
              "description": "Basic Mongoose setup and saving data from an Express POST route."
            }
          ],
          "quiz": [
            {
              "question": "Which package is commonly used to interact with MongoDB in Express?",
              "options": ["Mongoose", "Sequelize", "Axios", "MySQL"],
              "answer": "Mongoose",
              "hint": "It's an ODM for MongoDB.",
              "explanation": "Mongoose provides a schema-based solution to model MongoDB data in Node.js applications."
            }
          ],
          "challenge": "Create a MongoDB model for 'Product' and implement a POST route to add new products.",
          "tips": [
            "Always handle database errors using try/catch.",
            "Validate input before saving to the database."
          ]
        }
      ]
    },
    {
  "section": 7,
  "title": "Error Handling & Best Practices",
  "description": "Learn to handle errors effectively in Express.js and structure your applications for maintainability and scalability using best practices.",
  "lessons": [
    {
      "id": 15,
      "title": "Error Handling in Express",
      "content": "Use try/catch blocks, next(), and centralized error-handling middleware to manage errors and provide meaningful responses to clients.",
      "examples": [
        {
          "code": "app.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({ error: 'Something went wrong!' });\n});\n\napp.get('/', (req, res) => {\n  throw new Error('Test Error');\n});",
          "description": "Centralized error-handling middleware catches errors thrown in routes and returns JSON responses."
        }
      ],
      "quiz": [
        {
          "question": "Which function is used to pass errors to error-handling middleware?",
          "options": ["next(error)", "res.send(error)", "throw error", "console.error()"],
          "answer": "next(error)",
          "hint": "Middleware chain mechanism.",
          "explanation": "Passing an error to next(error) invokes Express’s error-handling middleware."
        },
        {
          "question": "Where should error-handling middleware be placed?",
          "options": ["After all routes", "Before all routes", "Inside app.listen", "Inside route handlers only"],
          "answer": "After all routes",
          "hint": "It should catch errors from any route.",
          "explanation": "Error-handling middleware must be defined after all routes to handle errors from any part of the app."
        }
      ],
      "challenge": "Implement error-handling middleware that returns JSON error responses for all API routes.",
      "tips": [
        "Log errors for debugging and monitoring.",
        "Use descriptive error messages but avoid exposing sensitive information.",
        "Always call next() with the error object in asynchronous code."
      ]
    },
    {
      "id": 16,
      "title": "Structuring Express Apps",
      "content": "Organize your Express applications using the MVC pattern, modular routes, and separate files for configuration, controllers, and models to improve scalability and maintainability.",
      "examples": [
        {
          "code": "project/\n├── app.js\n├── routes/\n│   └── userRoutes.js\n├── controllers/\n│   └── userController.js\n├── models/\n│   └── user.js\n└── config/\n    └── db.js",
          "description": "A clear folder structure separates concerns and makes the app easier to scale and maintain."
        }
      ],
      "quiz": [
        {
          "question": "Why separate controllers, routes, and models in Express?",
          "options": ["Maintainability and scalability", "To reduce npm packages", "Faster server", "For middleware only"],
          "answer": "Maintainability and scalability",
          "hint": "Think about code organization.",
          "explanation": "Separating concerns allows easier testing, debugging, and team collaboration."
        },
        {
          "question": "What does MVC stand for?",
          "options": ["Model, View, Controller", "Middleware, Variables, Config", "Module, View, Component", "Method, Version, Code"],
          "answer": "Model, View, Controller",
          "hint": "Common design pattern in web apps.",
          "explanation": "MVC separates data handling (Model), UI rendering (View), and logic (Controller)."
        }
      ],
      "challenge": "Refactor a small Express app by creating separate folders for routes, controllers, and models following the MVC pattern.",
      "tips": [
        "Keep routes thin and move business logic to controllers.",
        "Use a separate config file for environment variables and database connections.",
        "Follow consistent naming conventions for files and folders."
      ]
    }
  ]
}


  ]


}